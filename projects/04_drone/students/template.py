import numpy as np
from scipy import linalg
class RobotController:
    def __init__(self, limiter=None):
        self.dt = 0.01
        self.limiter = limiter
        self.A = np.array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0],
 [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0],
 [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0],
 [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, -0.0, 0.0],
 [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0],
 [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.0, 0.0, 1.0],
 [0.0, 0.0, 0.0, 0.0, 9.81, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
 [0.0, 0.0, 0.0, -9.81, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
 [0.0, 0.0, 0.0, -0.0, -0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
 [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.0, -0.0],
 [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
 [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]])
        self.B = np.array([[0.0, 0.0, 0.0, 0.0],
 [0.0, 0.0, 0.0, 0.0],
 [0.0, 0.0, 0.0, 0.0],
 [0.0, 0.0, 0.0, 0.0],
 [0.0, 0.0, 0.0, 0.0],
 [0.0, 0.0, 0.0, 0.0],
 [0.0, 0.0, 0.0, 0.0],
 [0.0, 0.0, 0.0, -0.0],
 [0.0, 0.0, 0.0, 2.0],
 [434.7826086956522, 0.0, 0.0, 0.0],
 [0.0, 434.7826086956522, 0.0, 0.0],
 [0.0, 0.0, 250.0, 0.0]])
        self.C = np.array([[1,0,0,0,0,0,0,0,0,0,0,0],
              [0,1,0,0,0,0,0,0,0,0,0,0],
              [0,0,1,0,0,0,0,0,0,0,0,0],
              [0,0,0,1,0,0,0,0,0,0,0,0],
              [0,0,0,0,1,0,0,0,0,0,0,0],
              [0,0,0,0,0,1,0,0,0,0,0,0]])
        self.K = np.array([[2.849239226069449e-16,
  -0.3162277660168379,
  7.712024080293069e-16,
  1.8187251855262583,
  3.414238572450682e-16,
  -3.6218381480570627e-16,
  -1.2004864030373425e-16,
  -0.4441329852036187,
  1.1092191283490692e-15,
  0.3582822014186871,
  -2.618926230116365e-17,
  -4.6447685377774406e-17],
 [0.316227766016838,
  5.562603342024433e-16,
  5.230864868288356e-17,
  -2.3884167985758553e-15,
  1.8187251855262518,
  -3.5063054481852274e-16,
  0.44413298520361716,
  6.270225059994137e-16,
  2.4197664673864283e-16,
  -2.618926230116365e-17,
  0.3582822014186872,
  -4.3258059302348805e-17],
 [-8.67563238404925e-17,
  1.3502054841318703e-16,
  -6.037585278792828e-16,
  -2.6336615002910333e-16,
  -2.0696998905784237e-15,
  0.44721359549995887,
  -4.1610829658436923e-16,
  3.3303759785560903e-18,
  -1.5247019565647122e-16,
  -2.6707419092220282e-17,
  -2.487338409885056e-17,
  0.3515362125926718],
 [1.183840535200479e-15,
  -2.395851931311368e-15,
  1.5811388300841913,
  6.909685424473608e-15,
  3.0853459095970048e-15,
  -3.9863961584182066e-16,
  1.2275069888914255e-15,
  -2.39462350101327e-15,
  1.8923897141139283,
  1.2756019976014293e-16,
  2.782731437494392e-17,
  -3.0494039131294246e-17]])
        self.L = np.array(
[[5.436123603459372, 0.0, 0.0, 0.0, 0.9584037479078862, 0.0],
 [0.0, 5.436123603459372, 0.0, -0.9584037479078862, 0.0, 0.0],
 [0.0, 0.0, 4.04036574091217, 0.0, 0.0, 0.0],
 [0.0, -0.9584037479078862, 0.0, 3.9194100991281804, 0.0, 0.0],
 [0.9584037479078862, 0.0, 0.0, 0.0, 3.9194100991281804, 0.0],
 [0.0, 0.0, 0.0, 0.0, 0.0, 4.04036574091217],
 [10.23498878804599, 0.0, 0.0, 0.0, 8.592993628376151, 0.0],
 [0.0, 10.23498878804599, 0.0, -8.592993628376151, 0.0, 0.0],
 [0.0, 0.0, 3.1622776601683764, 0.0, 0.0, 0.0],
 [0.0, -0.37338493586229526, 0.0, 3.1401566345759147, 0.0, 0.0],
 [0.37338493586229526, 0.0, 0.0, 0.0, 3.1401566345759147, 0.0],
 [0.0, 0.0, 0.0, 0.0, 0.0, 3.1622776601683764]])
        self.f_z_e = 9.81/2

    def get_color(self):
        return [1., 0., 0.]

    def reset(self, pos):
        self.xhat = np.array([[0.],[0.],[0.],[0.],[0.],[0.],[0.],[0.],[0.],[0.],[0.],[0.]])


    def run(self, pos, rpy, pos_ring, is_last_ring, pos_others):

        y = np.array([[pos[0]], [pos[1]], [pos[2]], [rpy[0]], [rpy[1]], [rpy[2]]])
        v_des = 1.5
        dist = linalg.norm([[pos_ring[0] - pos[0]], [pos_ring[1] - pos[1]], [pos_ring[2] - pos[2]]])
        displace_vec = ([[pos_ring[0] - pos[0]], [pos_ring[1] - pos[1]], [pos_ring[2] - pos[2]]])/dist
        v_vect = v_des * displace_vec
        x_des = np.array([[pos_ring[0]],[pos_ring[1]],[pos_ring[2]],[0.],[0.],[0.],[v_vect[0,0]],[v_vect[1,0]],[v_vect[2,0]],[0.],[0.],[0.]])

        max_error = 0.5

        for i in range(12):
            if np.abs(x_des[i,0] - self.xhat[i,0]) > max_error:
                x_des[i,0] = self.xhat[i,0] + max_error * ((x_des[i,0] - self.xhat[i,0]) / linalg.norm(x_des[i,0] - self.xhat[i,0]))
        
       #  x_des_array.append(x_des)

        u = -self.K @ (self.xhat - x_des)
        tau_x = u[0,0]
        tau_y = u[1,0]
        tau_z = u[2,0]
        if y[2,0] <= 0.5:
            u[3,0] = 2.5

        f_z = u[3,0] + self.f_z_e
        if self.limiter is not None:
            tau_x, tau_y, tau_z, f_z = self.limiter(tau_x, tau_y, tau_z, f_z)
        u[3,0] = f_z - self.f_z_e
        self.xhat += self.dt * (self.A @ self.xhat + self.B @ u - self.L @ (self.C @ self.xhat - y))

        return tau_x, tau_y, tau_z, f_z